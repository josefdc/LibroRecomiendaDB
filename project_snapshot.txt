# Estructura relevante del proyecto

LibroRecomienda/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ alembic.ini
‚îú‚îÄ‚îÄ collect_snapshot.py
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ env.py
‚îú‚îÄ‚îÄ project_snapshot.txt
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ generate_fake_data.py
‚îÇ   ‚îú‚îÄ‚îÄ populate_db.py
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ streamlit_app/
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py

# Contenido de archivos relevantes

--------------------------------------------------------------------------------
# README.md



--------------------------------------------------------------------------------
# alembic.ini

# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to migrations/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
version_path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = %(DATABASE_URL)s


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


--------------------------------------------------------------------------------
# collect_snapshot.py

#!/usr/bin/env python3
"""
snapshot_clean.py ‚Äï Exporta un TXT con la estructura ***concisa*** y el contenido
de los archivos realmente √∫tiles de un proyecto.

‚ñ´Ô∏è Filtros de directorio/archivo para ruido habitual (.venv, __pycache__, *.pyc‚Ä¶)
‚ñ´Ô∏è Lista blanca de extensiones relevantes (.py, .toml, .md, .yml‚Ä¶; ajustable)
‚ñ´Ô∏è Umbral de tama√±o (bytes) para saltarse binarios enormes accidentalmente
‚ñ´Ô∏è Opciones CLI para personalizar filtros sin tocar el c√≥digo

Ejemplo:
    python snapshot_clean.py . -o docs/snapshot.txt --only-ext .py,.md
"""
from __future__ import annotations

import argparse
from dataclasses import dataclass
import fnmatch
import os
from pathlib import Path
from typing import Iterable, List

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# CONFIGURACI√ìN POR DEFECTO ‚îÄ modif√≠cala si quieres, o usa las flags CLI
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
DEFAULT_IGNORE_DIRS = [
    ".git", ".venv", ".mypy_cache", ".pytest_cache", ".idea", ".vscode",
    "__pycache__", "*.egg-info", ".cache", ".tox", "dist", "build",
]
DEFAULT_IGNORE_FILES = [
    "*.pyc", "*.pyo", "*.so", "*.dylib", "*.log", "*.db", "*.sqlite3",
    "*.DS_Store", "*.lock", "*.zip", "*.tar.gz",
]
DEFAULT_ONLY_EXT = [
    ".py", ".toml", ".md", ".txt", ".ini", ".json", ".yaml", ".yml",
    ".sql", ".html", ".js", ".ts", ".css",
]
DEFAULT_MAX_SIZE = 1_000_000            # 1 MB

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# DATA STRUCTS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@dataclass
class Filters:
    ignore_dirs: List[str]
    ignore_files: List[str]
    only_ext:   List[str]
    max_size:   int


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# HELPERS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _matches(path: Path, patterns: Iterable[str]) -> bool:
    return any(fnmatch.fnmatch(path.name, pat) for pat in patterns)

def must_ignore(path: Path, f: Filters) -> bool:
    if path.is_dir():
        return _matches(path, f.ignore_dirs)
    # archivo
    if _matches(path, f.ignore_files):
        return True
    if f.only_ext and path.suffix.lower() not in f.only_ext:
        return True
    if f.max_size and path.stat().st_size > f.max_size:
        return True
    return False


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# DISCOVERY
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def collect_files(root: Path, f: Filters) -> List[Path]:
    relevant: List[Path] = []
    for dirpath, dirnames, filenames in os.walk(root):
        # purga de subdirectorios irrelevantes in-place
        dirnames[:] = [d for d in dirnames if not must_ignore(Path(d), f)]
        for name in filenames:
            fp = Path(dirpath) / name
            if not must_ignore(fp, f):
                relevant.append(fp)
    return sorted(relevant)

def build_tree(root: Path, files: List[Path]) -> str:
    """Dibuja el √°rbol mostrando solo ramas que contengan archivos relevantes."""
    # Conjunto de carpetas que s√≠ aportan algo
    keep_dirs = {root}
    for file in files:
        for parent in file.parents:
            keep_dirs.add(parent)
            if parent == root:
                break

    lines: List[str] = []
    for path in sorted(keep_dirs | set(files)):
        rel = path.relative_to(root)
        indent = "‚îÇ   " * (len(rel.parts) - 1)
        prefix = "‚îú‚îÄ‚îÄ " if rel.parts else ""
        lines.append(f"{indent}{prefix}{path.name}{'/' if path.is_dir() else ''}")
    return "\n".join(lines)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# MAIN
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def main() -> None:
    ap = argparse.ArgumentParser(description="Genera un snapshot limpio del proyecto.")
    ap.add_argument("root", nargs="?", default=".", help="Ra√≠z del proyecto")
    ap.add_argument("-o", "--output", default="project_snapshot.txt", help="Archivo de salida")
    ap.add_argument("--ignore-dirs", help="Patrones coma-separados extra para ignorar")
    ap.add_argument("--ignore-files", help="Patrones coma-separados extra para ignorar")
    ap.add_argument("--only-ext", help="Extensiones permitidas (ej: .py,.md) ‚Äï vac√≠o = todas")
    ap.add_argument("--max-size", type=int, default=DEFAULT_MAX_SIZE,
                    help=f"Tama√±o m√°ximo (bytes) de archivos a incluir (def {DEFAULT_MAX_SIZE})")
    args = ap.parse_args()

    filters = Filters(
        ignore_dirs=DEFAULT_IGNORE_DIRS + (args.ignore_dirs.split(",") if args.ignore_dirs else []),
        ignore_files=DEFAULT_IGNORE_FILES + (args.ignore_files.split(",") if args.ignore_files else []),
        only_ext=[e.lower() for e in (args.only_ext.split(",") if args.only_ext else DEFAULT_ONLY_EXT)],
        max_size=args.max_size,
    )

    root = Path(args.root).resolve()
    files = collect_files(root, filters)

    with open(args.output, "w", encoding="utf-8") as out:
        # 1. √Årbol compacto
        out.write("# Estructura relevante del proyecto\n\n")
        out.write(build_tree(root, files) + "\n\n")

        # 2. Contenido de archivos
        out.write("# Contenido de archivos relevantes\n")
        for fp in files:
            rel = fp.relative_to(root)
            out.write("\n" + "-" * 80 + f"\n# {rel}\n\n")
            try:
                out.write(fp.read_text(encoding="utf-8", errors="replace") + "\n")
            except Exception as e:
                out.write(f"<<No se pudo leer este archivo: {e}>>\n")

    print(f"Snapshot listo ‚Üí {args.output}")

if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------
# main.py

def main():
    print("Hello from librorecomienda!")


if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------
# migrations/env.py

import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool
from sqlalchemy import create_engine

from alembic import context

# Add the path to your source code
sys.path.insert(0, os.path.realpath(os.path.join(os.path.dirname(__file__), '..', 'src')))

# Import your Base and models
from librorecomienda.db.session import Base
from librorecomienda.models import *  # Import all models for migration discovery

# Import your settings
from librorecomienda.core.config import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    # Use the URL from your settings instead of the config
    url = settings.DATABASE_URL
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    # Use create_engine with your settings instead of engine_from_config
    connectable = create_engine(settings.DATABASE_URL)

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


--------------------------------------------------------------------------------
# project_snapshot.txt

# Estructura relevante del proyecto

LibroRecomienda/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ alembic.ini
‚îú‚îÄ‚îÄ collect_snapshot.py
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ env.py
‚îú‚îÄ‚îÄ project_snapshot.txt
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ generate_fake_data.py
‚îÇ   ‚îú‚îÄ‚îÄ populate_db.py
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ streamlit_app/
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py

# Contenido de archivos relevantes

--------------------------------------------------------------------------------
# README.md



--------------------------------------------------------------------------------
# alembic.ini

# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to migrations/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
version_path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = %(DATABASE_URL)s


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


--------------------------------------------------------------------------------
# collect_snapshot.py

#!/usr/bin/env python3
"""
snapshot_clean.py ‚Äï Exporta un TXT con la estructura ***concisa*** y el contenido
de los archivos realmente √∫tiles de un proyecto.

‚ñ´Ô∏è Filtros de directorio/archivo para ruido habitual (.venv, __pycache__, *.pyc‚Ä¶)
‚ñ´Ô∏è Lista blanca de extensiones relevantes (.py, .toml, .md, .yml‚Ä¶; ajustable)
‚ñ´Ô∏è Umbral de tama√±o (bytes) para saltarse binarios enormes accidentalmente
‚ñ´Ô∏è Opciones CLI para personalizar filtros sin tocar el c√≥digo

Ejemplo:
    python snapshot_clean.py . -o docs/snapshot.txt --only-ext .py,.md
"""
from __future__ import annotations

import argparse
from dataclasses import dataclass
import fnmatch
import os
from pathlib import Path
from typing import Iterable, List

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# CONFIGURACI√ìN POR DEFECTO ‚îÄ modif√≠cala si quieres, o usa las flags CLI
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
DEFAULT_IGNORE_DIRS = [
    ".git", ".venv", ".mypy_cache", ".pytest_cache", ".idea", ".vscode",
    "__pycache__", "*.egg-info", ".cache", ".tox", "dist", "build",
]
DEFAULT_IGNORE_FILES = [
    "*.pyc", "*.pyo", "*.so", "*.dylib", "*.log", "*.db", "*.sqlite3",
    "*.DS_Store", "*.lock", "*.zip", "*.tar.gz",
]
DEFAULT_ONLY_EXT = [
    ".py", ".toml", ".md", ".txt", ".ini", ".json", ".yaml", ".yml",
    ".sql", ".html", ".js", ".ts", ".css",
]
DEFAULT_MAX_SIZE = 1_000_000            # 1 MB

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# DATA STRUCTS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@dataclass
class Filters:
    ignore_dirs: List[str]
    ignore_files: List[str]
    only_ext:   List[str]
    max_size:   int


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# HELPERS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _matches(path: Path, patterns: Iterable[str]) -> bool:
    return any(fnmatch.fnmatch(path.name, pat) for pat in patterns)

def must_ignore(path: Path, f: Filters) -> bool:
    if path.is_dir():
        return _matches(path, f.ignore_dirs)
    # archivo
    if _matches(path, f.ignore_files):
        return True
    if f.only_ext and path.suffix.lower() not in f.only_ext:
        return True
    if f.max_size and path.stat().st_size > f.max_size:
        return True
    return False


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# DISCOVERY
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def collect_files(root: Path, f: Filters) -> List[Path]:
    relevant: List[Path] = []
    for dirpath, dirnames, filenames in os.walk(root):
        # purga de subdirectorios irrelevantes in-place
        dirnames[:] = [d for d in dirnames if not must_ignore(Path(d), f)]
        for name in filenames:
            fp = Path(dirpath) / name
            if not must_ignore(fp, f):
                relevant.append(fp)
    return sorted(relevant)

def build_tree(root: Path, files: List[Path]) -> str:
    """Dibuja el √°rbol mostrando solo ramas que contengan archivos relevantes."""
    # Conjunto de carpetas que s√≠ aportan algo
    keep_dirs = {root}
    for file in files:
        for parent in file.parents:
            keep_dirs.add(parent)
            if parent == root:
                break

    lines: List[str] = []
    for path in sorted(keep_dirs | set(files)):
        rel = path.relative_to(root)
        indent = "‚îÇ   " * (len(rel.parts) - 1)
        prefix = "‚îú‚îÄ‚îÄ " if rel.parts else ""
        lines.append(f"{indent}{prefix}{path.name}{'/' if path.is_dir() else ''}")
    return "\n".join(lines)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# MAIN
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def main() -> None:
    ap = argparse.ArgumentParser(description="Genera un snapshot limpio del proyecto.")
    ap.add_argument("root", nargs="?", default=".", help="Ra√≠z del proyecto")
    ap.add_argument("-o", "--output", default="project_snapshot.txt", help="Archivo de salida")
    ap.add_argument("--ignore-dirs", help="Patrones coma-separados extra para ignorar")
    ap.add_argument("--ignore-files", help="Patrones coma-separados extra para ignorar")
    ap.add_argument("--only-ext", help="Extensiones permitidas (ej: .py,.md) ‚Äï vac√≠o = todas")
    ap.add_argument("--max-size", type=int, default=DEFAULT_MAX_SIZE,
                    help=f"Tama√±o m√°ximo (bytes) de archivos a incluir (def {DEFAULT_MAX_SIZE})")
    args = ap.parse_args()

    filters = Filters(
        ignore_dirs=DEFAULT_IGNORE_DIRS + (args.ignore_dirs.split(",") if args.ignore_dirs else []),
        ignore_files=DEFAULT_IGNORE_FILES + (args.ignore_files.split(",") if args.ignore_files else []),
        only_ext=[e.lower() for e in (args.only_ext.split(",") if args.only_ext else DEFAULT_ONLY_EXT)],
        max_size=args.max_size,
    )

    root = Path(args.root).resolve()
    files = collect_files(root, filters)

    with open(args.output, "w", encoding="utf-8") as out:
        # 1. √Årbol compacto
        out.write("# Estructura relevante del proyecto\n\n")
        out.write(build_tree(root, files) + "\n\n")

        # 2. Contenido de archivos
        out.write("# Contenido de archivos relevantes\n")
        for fp in files:
            rel = fp.relative_to(root)
            out.write("\n" + "-" * 80 + f"\n# {rel}\n\n")
            try:
                out.write(fp.read_text(encoding="utf-8", errors="replace") + "\n")
            except Exception as e:
                out.write(f"<<No se pudo leer este archivo: {e}>>\n")

    print(f"Snapshot listo ‚Üí {args.output}")

if __name__ == "__main__":
    main()



--------------------------------------------------------------------------------
# pyproject.toml

[project]
name = "librorecomienda"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.11"
dependencies = [
    "alembic>=1.15.2",
    "fastapi>=0.115.12",
    "httpx>=0.28.1",
    "langchain>=0.3.24",
    "langgraph>=0.3.34",
    "openai>=1.76.0",
    "passlib[bcrypt]>=1.7.4",
    "psycopg2-binary>=2.9.10",
    "pydantic[email]>=2.11.3",
    "pydantic-settings>=2.9.1",
    "python-dotenv>=1.1.0",
    "sqlalchemy>=2.0.40",
    "streamlit>=1.44.1",
    "uvicorn[standard]>=0.34.2",
]

[dependency-groups]
dev = [
    "faker>=37.1.0",
]


--------------------------------------------------------------------------------
# scripts/generate_fake_data.py

# scripts/generate_fake_data.py
import random
import logging
import sys
import os # Necesario para la importaci√≥n relativa si no se usa uv run
from faker import Faker
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError # Para capturar errores espec√≠ficos

# --- Configuraci√≥n del Logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- A√±adir 'src' al PYTHONPATH (alternativa si no usas 'uv run') ---
# current_dir = os.path.dirname(os.path.abspath(__file__))
# project_root = os.path.dirname(current_dir)
# src_path = os.path.join(project_root, 'src')
# if src_path not in sys.path:
#     sys.path.insert(0, src_path)

# --- Importaciones del Proyecto ---
try:
    from librorecomienda.db.session import SessionLocal
    from librorecomienda.models.user import User
    from librorecomienda.models.book import Book
    from librorecomienda.models.review import Review
    from librorecomienda.schemas.user import UserCreate
    from librorecomienda.schemas.review import ReviewCreate
    from librorecomienda.crud.crud_user import create_user, get_user_by_email
    from librorecomienda.crud.crud_review import create_review
    MODELS_LOADED = True
    logger.info("M√≥dulos del proyecto importados correctamente.")
except ImportError as e:
    logger.error(f"Error importando m√≥dulos: {e}.")
    logger.error("Aseg√∫rate de haber ejecutado 'uv pip install -e .'")
    logger.error("Y que los archivos CRUD/Schemas/Models existen y son importables.")
    MODELS_LOADED = False
    sys.exit(1) # Salir si hay error cr√≠tico

# --- Constantes de Configuraci√≥n ---
NUM_FAKE_USERS = 50        # N√∫mero de usuarios falsos a crear/verificar
MAX_REVIEWS_PER_USER = 15  # M√°ximo n√∫mero de rese√±as por cada usuario
MIN_REVIEWS_PER_USER = 2   # M√≠nimo n√∫mero de rese√±as por cada usuario
FAKE_PASSWORD = "password123" # Contrase√±a com√∫n para usuarios de prueba

# --- Inicializar Faker ---
fake = Faker(['es_ES', 'en_US']) # M√∫ltiples locales para variedad de nombres/emails
logger.info("Instancia de Faker creada.")

# --- Funci√≥n Principal ---
def generate_data():
    if not MODELS_LOADED:
        logger.error("No se pudieron cargar los m√≥dulos del proyecto. Abortando.")
        return

    logger.info("=============================================")
    logger.info(" Iniciando script de generaci√≥n de datos falsos")
    logger.info("=============================================")

    db: Session | None = None
    created_user_ids = []
    book_ids = []

    try:
        logger.info("Abriendo sesi√≥n de base de datos...")
        db = SessionLocal()

        # 1. Crear o Verificar Usuarios Falsos
        logger.info(f"--- Fase 1: Creando/Verificando {NUM_FAKE_USERS} Usuarios Falsos ---")
        for i in range(NUM_FAKE_USERS):
            # --- Comenta o borra estas l√≠neas ---
            # first_name = fake.first_name().lower().replace("'", "") # Evitar ap√≥strofes
            # last_name = fake.last_name().lower().replace("'", "")
            # domain = fake.domain_name()
            # Construir email m√°s realista y √∫nico
            # fake_email = f"{first_name}.{last_name}{random.randint(1,999)}@{domain}"

            # --- Usa esta l√≠nea en su lugar ---
            fake_email = fake.safe_email()
            # Opcional: puedes a√±adir un log para ver qu√© genera
            # logger.debug(f"Generated safe email: {fake_email}")

            # Verificar si ya existe en la BD
            existing_user = get_user_by_email(db, email=fake_email)

            if not existing_user:
                user_in = UserCreate(email=fake_email, password=FAKE_PASSWORD)
                try:
                    # La funci√≥n create_user ya hace commit y refresh
                    new_user = create_user(db=db, user=user_in)
                    created_user_ids.append(new_user.id)
                    logger.info(f"  ({i+1}/{NUM_FAKE_USERS}) Usuario Creado: {new_user.email} (ID: {new_user.id})")
                except IntegrityError: # Captura error si el email ya existe (raro por el n√∫mero aleatorio)
                     db.rollback() # Deshacer la transacci√≥n fallida
                     logger.warning(f"  ({i+1}/{NUM_FAKE_USERS}) Error de integridad al crear {fake_email}, probablemente ya existe. Intentando obtenerlo...")
                     existing_user = get_user_by_email(db, email=fake_email)
                     if existing_user:
                          created_user_ids.append(existing_user.id)
                except Exception as e:
                    logger.error(f"  ({i+1}/{NUM_FAKE_USERS}) Error inesperado creando usuario {fake_email}: {e}")
                    db.rollback() # Deshacer si hay otro error
            else:
                # Si ya existe, simplemente usamos su ID
                logger.info(f"  ({i+1}/{NUM_FAKE_USERS}) Usuario Encontrado: {existing_user.email} (ID: {existing_user.id})")
                created_user_ids.append(existing_user.id)

        if not created_user_ids:
            logger.error("No se pudieron crear ni encontrar usuarios. Abortando generaci√≥n de rese√±as.")
            return

        logger.info(f"--- Fase 1 Completada: {len(created_user_ids)} IDs de usuario listos. ---")

        # 2. Obtener IDs de Libros Existentes
        logger.info("--- Fase 2: Obteniendo IDs de Libros Existentes ---")
        book_ids = [id_tuple[0] for id_tuple in db.query(Book.id).all()] # Extraer el ID de la tupla
        if not book_ids:
            logger.error("No hay libros en la base de datos. No se pueden generar rese√±as.")
            return
        logger.info(f"Se encontraron {len(book_ids)} libros disponibles.")
        logger.info("--- Fase 2 Completada. ---")


        # 3. Crear Rese√±as Falsas
        logger.info(f"--- Fase 3: Generando Rese√±as Falsas ({MIN_REVIEWS_PER_USER}-{MAX_REVIEWS_PER_USER} por usuario) ---")
        total_reviews_added = 0
        processed_users = 0

        for user_id in created_user_ids:
            processed_users += 1
            # Determinar cu√°ntas rese√±as har√° este usuario
            num_reviews_to_create = random.randint(MIN_REVIEWS_PER_USER, min(MAX_REVIEWS_PER_USER, len(book_ids)))

            # Seleccionar libros al azar para este usuario (sin repetici√≥n)
            # Asegurarse de que num_reviews_to_create no sea mayor que los libros disponibles
            actual_num_reviews = min(num_reviews_to_create, len(book_ids))
            if actual_num_reviews <= 0:
                continue # No hay libros para rese√±ar o num_reviews es 0
            selected_book_ids = random.sample(book_ids, actual_num_reviews)

            logger.info(f"  Usuario ID: {user_id} ({processed_users}/{len(created_user_ids)}) - Creando {actual_num_reviews} rese√±as...")

            reviews_for_this_user = 0
            for book_id in selected_book_ids:
                # Generar datos de la rese√±a
                fake_rating = random.randint(1, 5)
                # Generar comentario con probabilidad (ej: 70% de las veces)
                fake_comment_text = fake.paragraph(nb_sentences=random.randint(1, 4)) if random.random() < 0.7 else None

                try:
                    # Crear el objeto schema
                    review_in = ReviewCreate(rating=fake_rating, comment=fake_comment_text)
                    # Llamar a la funci√≥n CRUD (que hace commit)
                    create_review(db=db, review=review_in, user_id=user_id, book_id=book_id)
                    reviews_for_this_user += 1
                except IntegrityError as ie:
                     # Podr√≠a ocurrir si ya existe una rese√±a para este user/book y tienes UniqueConstraint
                     logger.warning(f"  Error de integridad al crear review para User {user_id}, Book {book_id}: {ie}. ¬øYa existe?")
                     db.rollback() # Deshacer transacci√≥n fallida
                except Exception as e:
                    logger.error(f"  Error inesperado creando review para User {user_id}, Book {book_id}: {e}")
                    db.rollback() # Deshacer transacci√≥n fallida

            if reviews_for_this_user > 0:
                 logger.info(f"  Usuario ID: {user_id} - Se crearon {reviews_for_this_user} rese√±as.")
                 total_reviews_added += reviews_for_this_user
            # No es necesario commit aqu√≠ si create_review ya lo hace

        logger.info(f"--- Fase 3 Completada: Total rese√±as falsas a√±adidas: {total_reviews_added} ---")

    except Exception as e:
        logger.exception(f"Error CR√çTICO durante la generaci√≥n de datos: {e}")
        if db: db.rollback() # Intentar deshacer si hubo un error grave
    finally:
        if db:
            logger.info("Cerrando sesi√≥n de base de datos.")
            db.close()

# --- Punto de Entrada del Script ---
if __name__ == "__main__":
    generate_data()
    logger.info("============================================")
    logger.info(" Script de Generaci√≥n de Datos Finalizado")
    logger.info("============================================")


--------------------------------------------------------------------------------
# scripts/populate_db.py

# scripts/populate_db.py
import logging
import sys
import os
import asyncio # Import asyncio

# --- Configuraci√≥n del Logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- A√±adir 'src' al PYTHONPATH (si es necesario) ---
# ... (c√≥digo existente para a√±adir src al path) ...

# --- Importaciones del Proyecto ---
try:
    from sqlalchemy.orm import Session
    from librorecomienda.db.session import SessionLocal
    from librorecomienda.models.book import Book
    # --- Cambiar esta l√≠nea ---
    from librorecomienda.clients.google_books import search_books_google_api
    # -------------------------
    from librorecomienda.core.config import settings
    MODELS_LOADED = True
    logger.info("M√≥dulos del proyecto importados correctamente.")
except ImportError as e:
    logger.error(f"Error importando m√≥dulos: {e}.")
    logger.error("Aseg√∫rate de haber ejecutado 'uv pip install -e .' y 'uv pip install httpx'")
    MODELS_LOADED = False
    sys.exit(1)

# --- Constantes ---
SEARCH_QUERIES = [
    "python programming",
    "data science",
    "machine learning",
    "artificial intelligence",
    "software engineering best practices",
    "classic literature",
    "science fiction",
    "fantasy novels",
    "historical fiction",
    "biography"
]
MAX_RESULTS_PER_QUERY = 10 # N√∫mero de libros a intentar obtener por cada b√∫squeda

# --- Funci√≥n para Poblar Libros ---
def populate_books(db: Session):
    if not MODELS_LOADED:
        logger.error("No se pudieron cargar los m√≥dulos. Abortando poblaci√≥n.")
        return

    logger.info("--- Iniciando Poblaci√≥n de Libros --- ")
    # No necesitamos instanciar un cliente
    total_books_added = 0

    for query in SEARCH_QUERIES:
        logger.info(f"Buscando libros para: '{query}'...")
        try:
            # --- Llamar a la funci√≥n async usando asyncio.run() ---
            google_books_data = asyncio.run(
                search_books_google_api(query, max_results=MAX_RESULTS_PER_QUERY)
            )
            # -----------------------------------------------------

            if google_books_data is None: # La funci√≥n devuelve None en caso de error
                logger.error(f"Error al buscar libros para '{query}'. Ver logs anteriores.")
                continue
            if not google_books_data:
                logger.warning(f"No se encontraron resultados para '{query}'.")
                continue

            logger.info(f"Se encontraron {len(google_books_data)} resultados para '{query}'. Procesando...")

            for item in google_books_data:
                volume_info = item.get('volumeInfo', {})

                title = volume_info.get('title')
                authors = volume_info.get('authors', [])
                author_str = ", ".join(authors) if authors else None
                description = volume_info.get('description')
                genre = volume_info.get('categories', [None])[0] # Tomar la primera categor√≠a como g√©nero
                image_links = volume_info.get('imageLinks', {})
                cover_url = image_links.get('thumbnail') or image_links.get('smallThumbnail')

                # --- Extraer ISBN --- 
                industry_identifiers = volume_info.get('industryIdentifiers', [])
                isbn_13 = None
                isbn_10 = None
                for identifier in industry_identifiers:
                    id_type = identifier.get('type')
                    id_value = identifier.get('identifier')
                    if id_type == 'ISBN_13':
                        isbn_13 = id_value
                    elif id_type == 'ISBN_10':
                        isbn_10 = id_value

                # Priorizamos ISBN_13 si existe, si no, usamos ISBN_10
                book_isbn = isbn_13 if isbn_13 else isbn_10
                # Truncar si excede el l√≠mite de la BD (String(20))
                book_isbn = book_isbn[:20] if book_isbn else None
                # --------------------

                if not title:
                    logger.warning("Libro sin t√≠tulo encontrado, saltando.")
                    continue

                # Evitar duplicados
                exists = db.query(Book).filter(Book.title == title, Book.author == author_str).first()
                if exists:
                    logger.info(f"Libro ya existe (t√≠tulo/autor): '{title}'. Saltando.")
                    continue
                if book_isbn:
                     exists_isbn = db.query(Book).filter(Book.isbn == book_isbn).first()
                     if exists_isbn:
                           logger.info(f"Libro ya existe (ISBN): '{title}' [{book_isbn}]. Saltando.")
                           continue

                new_book = Book(
                    title=title[:255],
                    author=author_str[:255] if author_str else None,
                    genre=genre[:100] if genre else None,
                    description=description,
                    cover_image_url=cover_url[:512] if cover_url else None,
                    isbn=book_isbn
                )
                db.add(new_book)
                total_books_added += 1
                logger.info(f"  A√±adido: '{new_book.title}' (ISBN: {new_book.isbn or 'N/A'})")

            # Hacer commit por lotes
            try:
                db.commit()
                logger.info(f"Commit realizado para libros de '{query}'.")
            except Exception as commit_exc:
                logger.error(f"Error haciendo commit para '{query}': {commit_exc}")
                db.rollback()

        except Exception as e:
            logger.exception(f"Error procesando la query '{query}': {e}")
            db.rollback()

    logger.info(f"--- Poblaci√≥n de Libros Finalizada: {total_books_added} libros a√±adidos en total. ---")

# --- Punto de Entrada --- 
if __name__ == "__main__":
    db_session: Session | None = None
    try:
        logger.info("Abriendo sesi√≥n de base de datos para poblar...")
        db_session = SessionLocal()
        populate_books(db_session)
    except Exception as main_exc:
        logger.exception(f"Error CR√çTICO durante la poblaci√≥n: {main_exc}")
    finally:
        if db_session:
            logger.info("Cerrando sesi√≥n de base de datos.")
            db_session.close()

--------------------------------------------------------------------------------
# src/__init__.py



--------------------------------------------------------------------------------
# streamlit_app/app.py

# streamlit_app/app.py
import streamlit as st
import pandas as pd
import time
from sqlalchemy.orm import Session

# Importaciones del proyecto (ajusta las rutas seg√∫n tu estructura)
from librorecomienda.db.session import SessionLocal
from librorecomienda.models.book import Book
from librorecomienda.models.user import User # Aseg√∫rate de importar User
from librorecomienda.schemas.user import UserCreate
from librorecomienda.schemas.review import ReviewCreate
from librorecomienda.crud import (
    create_user,
    get_user_by_email,
    create_review,
    get_reviews_for_book_with_user,
    get_users,
    soft_delete_review,
    get_all_reviews_admin, # <-- Import get_all_reviews_admin
)
from librorecomienda.core.security import verify_password, get_password_hash
from librorecomienda.core.config import settings # Importar settings

# --- Inicializaci√≥n del Estado de Sesi√≥n ---
if 'logged_in' not in st.session_state:
    st.session_state['logged_in'] = False
    st.session_state['user_email'] = None
    st.session_state['user_id'] = None
    st.session_state['is_admin'] = False # <-- A√±adir esta l√≠nea

# ... (resto de inicializaciones si las hay) ...

# --- Funciones Auxiliares (si las tienes) ---
# Ejemplo de funci√≥n para cargar libros (si la tienes separada)
# Si no, la l√≥gica estar√° directamente en la secci√≥n principal
@st.cache_data(ttl=3600) # Cachear por 1 hora
def load_books_from_db():
    db: Session | None = None
    try:
        db = SessionLocal()
        # Seleccionar todas las columnas necesarias, incluyendo isbn
        books_result = db.query(
            Book.id, Book.title, Book.author, Book.genre,
            Book.average_rating, Book.description,
            Book.cover_image_url,
            Book.isbn  # <-- Aseg√∫rate que esta columna est√© seleccionada
        ).order_by(Book.title).all() # Ordenar por t√≠tulo para consistencia

        # Convertir a un objeto m√°s f√°cil de usar si prefieres (opcional)
        # import types # Necesitar√≠as importar types
        # books_data = [
        #     types.SimpleNamespace(
        #         id=row.id, title=row.title, author=row.author, genre=row.genre,
        #         average_rating=row.average_rating, description=row.description,
        #         cover_image_url=row.cover_image_url,
        #         isbn=row.isbn # <-- A√±ade el isbn aqu√≠ tambi√©n
        #     ) for row in books_result
        # ]
        # return books_data
        return books_result # Devolver directamente los resultados de SQLAlchemy (Row objects)
    except Exception as e:
        st.error(f"Error cargando libros desde la base de datos: {e}")
        return []
    finally:
        if db:
            db.close()

# --- Barra Lateral: Login / Registro / Logout ---
st.sidebar.title("Acceso")

if not st.session_state.get('logged_in', False):
    login_tab, register_tab = st.sidebar.tabs(["Iniciar Sesi√≥n", "Registrarse"])

    with login_tab:
        with st.form("login_form"):
            st.subheader("Iniciar Sesi√≥n")
            login_email = st.text_input("Email", key="login_email")
            login_password = st.text_input("Contrase√±a", type="password", key="login_password")
            login_submitted = st.form_submit_button("Entrar")

            if login_submitted:
                if not login_email or not login_password:
                    st.warning("Por favor, introduce email y contrase√±a.")
                else:
                    db: Session | None = None
                    try:
                        db = SessionLocal()
                        user = get_user_by_email(db, email=login_email)
                        if user and user.is_active and verify_password(login_password, user.hashed_password):
                            st.session_state['logged_in'] = True
                            st.session_state['user_email'] = user.email
                            st.session_state['user_id'] = user.id
                            # --- A√±adir esta verificaci√≥n ---
                            if user.email in settings.list_admin_emails:
                                st.session_state['is_admin'] = True
                                st.toast("Acceso de administrador concedido.", icon="üîë")
                            else:
                                st.session_state['is_admin'] = False
                            # --- Fin de la verificaci√≥n ---
                            st.success("¬°Login exitoso!")
                            time.sleep(1)
                            # No cerrar db aqu√≠ si se necesita m√°s adelante en la misma ejecuci√≥n
                            # db.close() # Mover close si es posible o gestionarlo al final
                            st.rerun()
                        else:
                            st.error("Email o contrase√±a incorrectos.")
                    except Exception as e:
                        st.error(f"Error durante el login: {e}")
                    finally:
                        if db:
                            db.close()

    with register_tab:
        with st.form("register_form"):
            st.subheader("Registrarse")
            register_email = st.text_input("Email", key="register_email")
            register_password = st.text_input("Contrase√±a", type="password", key="register_password")
            register_confirm_password = st.text_input("Confirmar Contrase√±a", type="password", key="register_confirm_password")
            register_submitted = st.form_submit_button("Registrar")

            if register_submitted:
                if not register_email or not register_password or not register_confirm_password:
                    st.warning("Por favor, rellena todos los campos.")
                elif register_password != register_confirm_password:
                    st.error("Las contrase√±as no coinciden.")
                else:
                    db: Session | None = None
                    try:
                        db = SessionLocal()
                        existing_user = get_user_by_email(db, email=register_email)
                        if existing_user:
                            st.error("Este email ya est√° registrado.")
                        else:
                            user_in = UserCreate(email=register_email, password=register_password)
                            new_user = create_user(db=db, user=user_in)
                            st.success(f"¬°Usuario {new_user.email} registrado con √©xito! Ahora puedes iniciar sesi√≥n.")
                            time.sleep(2)
                            # Podr√≠as hacer login autom√°tico aqu√≠ o simplemente limpiar
                    except Exception as e:
                        st.error(f"Error durante el registro: {e}")
                    finally:
                        if db:
                            db.close()
else:
    st.sidebar.write(f"Conectado como: {st.session_state['user_email']}")
    if st.session_state.get('is_admin', False):
        st.sidebar.markdown("**Rol:** Administrador üîë")
    if st.sidebar.button("Cerrar Sesi√≥n"):
        st.session_state['logged_in'] = False
        st.session_state['user_email'] = None
        st.session_state['user_id'] = None
        st.session_state['is_admin'] = False # <-- A√±adir esta l√≠nea
        st.success("Sesi√≥n cerrada.")
        time.sleep(1)
        st.rerun()

# --- T√≠tulo Principal --- 
st.title("üìö LibroRecomienda")
st.write("Encuentra y comparte rese√±as de tus libros favoritos.")

# --- Cat√°logo de Libros y Rese√±as --- 
try:
    # Cargar libros (usando la funci√≥n cacheada o directamente)
    # all_books = load_books_from_db() # Si usas la funci√≥n auxiliar
    db_main = SessionLocal() # Abrir sesi√≥n si no usas la funci√≥n auxiliar
    all_books = db_main.query(Book).order_by(Book.title).all() # Carga directa

    if not all_books:
        st.warning("No hay libros en la base de datos. Ejecuta `scripts/populate_db.py`.")
    else:
        st.header("Cat√°logo de Libros")
        # Aqu√≠ ir√≠a tu l√≥gica de filtros y b√∫squeda si la tienes
        # Ejemplo simple de filtro (si lo implementas)
        # search_term = st.text_input("Buscar libro por t√≠tulo o autor")
        # filtered_books = [book for book in all_books if search_term.lower() in book.title.lower() or (book.author and search_term.lower() in book.author.lower())] if search_term else all_books
        filtered_books = all_books # Sin filtro por ahora

        for book in filtered_books:
            # Usar book.id como parte de la clave del expander para unicidad
            # Se elimina el argumento 'key' para compatibilidad con versiones anteriores de Streamlit
            with st.expander(f"{book.title} ({book.author or 'Autor Desconocido'})"):
                col1, col2 = st.columns([1, 3])
                with col1:
                    if book.cover_image_url:
                        # A√±adir manejo de errores para la imagen
                        try:
                            st.image(book.cover_image_url, width=150)
                        except Exception as img_e:
                            st.caption(f"Error cargando portada: {img_e}")
                    else:
                        st.caption("Sin portada")
                with col2:
                    st.subheader(f"{book.title}")
                    st.write(f"**Autor:** {book.author or 'Desconocido'}")
                    # st.write(f"**A√±o:** {book.publication_year}") # Ya comentado/eliminado
                    # --- Mostrar ISBN si existe --- 
                    if book.isbn:
                        st.write(f"**ISBN:** {book.isbn}")
                    # -------------------------------
                    st.write(f"**G√©nero:** {book.genre or 'Desconocido'}")
                    # Mostrar descripci√≥n si existe
                    if book.description:
                        st.caption(f"Descripci√≥n: {book.description[:200]}...") # Mostrar solo una parte

                # --- Secci√≥n de Rese√±as ---
                st.markdown("#### Rese√±as de otros usuarios")
                # Asegurarse de pasar la sesi√≥n correcta a las funciones CRUD
                # Use the updated function that returns Row objects (Review, User.email)
                reviews_data = get_reviews_for_book_with_user(db=db_main, book_id=book.id)
                if reviews_data:
                    # reviews_data is a list of Row objects, access attributes by name
                    for review_row in reviews_data:
                        review = review_row.Review # Access the Review object
                        user_email = review_row.email # Access the user's email

                        # Display review details
                        st.markdown(f"**{user_email or 'Usuario Desconocido'}** ({'‚≠ê'*review.rating}):")
                        if review.comment:
                            st.markdown(f"> *{review.comment}*")
                        st.caption(f"_{review.created_at.strftime('%Y-%m-%d %H:%M') if review.created_at else 'Fecha desconocida'}_")

                        # --- Bot√≥n Borrar (si es mi rese√±a y estoy logueado) ---
                        # Compara el user_id de la rese√±a con el user_id en session_state
                        if st.session_state.get('logged_in', False) and review.user_id == st.session_state.get('user_id'):
                            # Usamos un key √∫nico para cada bot√≥n de borrar
                            if st.button("üóëÔ∏è Borrar mi rese√±a", key=f"delete_review_{review.id}", type="secondary"):
                                # Optional: Add a confirmation step if desired
                                # st.warning("¬øEst√°s seguro?")
                                # if st.button("Confirmar Borrado", key=f"confirm_delete_{review.id}"):
                                delete_db: Session | None = None
                                try:
                                    delete_db = SessionLocal()
                                    # Llamar a la funci√≥n CRUD de borrado l√≥gico
                                    success = soft_delete_review(
                                        db=delete_db,
                                        review_id=review.id, # Pasar el ID de la rese√±a actual
                                        requesting_user_id=st.session_state['user_id']
                                    )
                                    if success:
                                        st.toast("Rese√±a borrada.", icon="üóëÔ∏è")
                                        # Limpiar cach√© si usas @st.cache_data en load_books_from_db
                                        # O simplemente limpiar la cach√© general de datos si afecta a las rese√±as
                                        st.cache_data.clear()
                                        time.sleep(1) # Pausa para ver el toast
                                        st.rerun() # Refrescar la p√°gina
                                    else:
                                        # Podr√≠a ser que no se encontr√≥ o no ten√≠a permiso (soft_delete_review ya loguea el error)
                                        st.warning("No se pudo borrar la rese√±a (quiz√°s ya estaba borrada o hubo un problema).")
                                except Exception as e_del:
                                    st.error(f"Error al intentar borrar: {e_del}")
                                finally:
                                    if delete_db:
                                        delete_db.close()
                        st.markdown("---") # Separator between reviews
                else:
                    st.caption("Todav√≠a no hay rese√±as para este libro.")

                # --- A√±adir Rese√±a (Solo si est√° logueado) ---
                if st.session_state.get('logged_in', False):
                    st.markdown("#### A√±ade tu rese√±a")
                    # Usar book.id en la clave del formulario para unicidad
                    with st.form(key=f"review_form_{book.id}"):
                        rating = st.slider("Puntuaci√≥n", 1, 5, 3, key=f"rating_{book.id}")
                        comment = st.text_area("Comentario (opcional)", key=f"comment_{book.id}")
                        submit_review = st.form_submit_button("Enviar Rese√±a")

                        if submit_review:
                            review_in = ReviewCreate(rating=rating, comment=comment)
                            try:
                                # Asegurarse de pasar la sesi√≥n correcta
                                create_review(db=db_main, review=review_in, user_id=st.session_state['user_id'], book_id=book.id)
                                st.success("¬°Rese√±a a√±adida con √©xito!")
                                time.sleep(1)
                                # Limpiar cache si usas @st.cache_data en load_books_from_db
                                # load_books_from_db.clear()
                                st.rerun() # Recargar para ver la nueva rese√±a
                            except Exception as e:
                                st.error(f"Error al a√±adir la rese√±a: {e}")
                                # db_main.rollback() # Rollback si es necesario

except Exception as e:
    st.error(f"Error cargando los libros o rese√±as: {e}")
    # Asegurarse de cerrar la sesi√≥n si se abri√≥ aqu√≠
    if 'db_main' in locals() and db_main:
        db_main.close()
finally:
    # Asegurarse de cerrar la sesi√≥n si se abri√≥ en el bloque try principal
    if 'db_main' in locals() and db_main:
        db_main.close()


# --- Secci√≥n de Administraci√≥n (Solo visible para admins) ---
if st.session_state.get('is_admin'):
    st.sidebar.divider()
    st.sidebar.header("Panel de Administraci√≥n")
    admin_option = st.sidebar.radio("Selecciona una vista:", ["Gesti√≥n de Usuarios", "Gesti√≥n de Rese√±as"], key="admin_view")

    with db:
        if admin_option == "Gesti√≥n de Usuarios":
            st.subheader("Gesti√≥n de Usuarios")
            users_data = get_users(db) # Use directly
            if users_data:
                # Crear un DataFrame de Pandas para mostrar en tabla
                # Usamos los nombres de columna que seleccionamos en get_users
                # Aseg√∫rate de que pandas est√° instalado: uv pip install pandas
                try:
                    import pandas as pd
                    df_users = pd.DataFrame(users_data, columns=['ID', 'Email', 'Activo', 'Creado', 'Actualizado'])
                    st.dataframe(df_users, use_container_width=True)
                except ImportError:
                    st.error("La librer√≠a 'pandas' no est√° instalada. Por favor, ejecute `uv pip install pandas`.")
                    st.write("Datos de usuarios (sin formato tabla):")
                    st.write(users_data) # Mostrar datos crudos si pandas no est√°
            else:
                st.write("No hay usuarios registrados.")

        elif admin_option == "Gesti√≥n de Rese√±as": # <-- Use elif
            st.subheader("Gesti√≥n de Rese√±as")
            reviews_admin_data = get_all_reviews_admin(db) # Use directly
            if reviews_admin_data:
                reviews_list = []
                for review, user_email, book_title in reviews_admin_data:
                    reviews_list.append(
                        {
                            "ID Rese√±a": review.id,
                            "Libro": book_title,
                            "Usuario": user_email,
                            "Puntuaci√≥n": review.rating,
                            "Comentario": review.comment,
                            "Fecha": review.created_at.strftime("%Y-%m-%d %H:%M"),
                            "Estado": "BORRADO" if review.is_deleted else "Activo",
                        }
                    )
                reviews_df = pd.DataFrame(reviews_list)
                st.dataframe(reviews_df, use_container_width=True)
            else:
                st.write("No hay rese√±as para mostrar.")

# --- Fin Panel de Administraci√≥n ---

st.divider()

--------------------------------------------------------------------------------
# tests/__init__.py


